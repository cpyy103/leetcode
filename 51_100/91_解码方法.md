# [解码方法](https://leetcode-cn.com/problems/decode-ways/)

## 描述  
**中等**  

一条包含字母 A-Z 的消息通过以下方式进行了编码：

    'A' -> 1
    'B' -> 2
    ...
    'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

**示例 1:**

    输入: "12"
    输出: 2
    解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
**示例 2:**

    输入: "226"
    输出: 3
    解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

## 解题  

动态规划  

两种对应 

- 1个数字决定一个字符
- 2个数字决定一个字符  

一般情况下，当前的解码数为前一个解码数加前前一个解码数    

`dp[i]`表示`s[:i]`时的编码数  

`dp[i] = dp[i-1]+dp[i-2]`  （当前为一个数字解码的情况和当前数据与前一个数字一起解码的情况之和）

但是A-Z对应1-26，没有0，所以需要考虑当前数字为0的情况  
- 如果当前数字为0
    - 如果前一个数字为1或2，那么肯定是两个数字一起解码  
    - `dp[i] = dp[i-2]`
    - 如果前一个数字不是1或2，例如3，那么30没有对应字母，无解  
    - `return 0`
    
- 如果当前数字不为0
    - 如果（前一个数字为1或2，并且当前数字为1到6之间 ）或者（前一个数为1，当前数无限制） 
    那么肯定，当前解码可以是单独一个数解码，也可以是两个数解码  
    - `dp[i] = dp[i-1]+dp[i-2]`
    - 其他，也就是当前数字和前一位数字不在10-26间，那么只能是当前一个数字解码成一个字母  
    - `dp[i] = dp[i-1]`

代码中需要初始化`dp[0]`和`dp[1]`   

但是初始化dp[1]需要上述条件的判断s[1]

设置的dp，`len(dp)=length+1`，解决了重复判断s[1]来初始化的情况
此时的dp[i+1]相当于s[i]的编码数

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        if s[0] == '0':
            return 0
        if len(s) == 1:
            return 1

        length = len(s)
  
        dp = [1 for _ in range(length+1)]

        for i in range(1, length):
            if s[i] == '0':
                if s[i-1]=='1' or s[i-1]=='2':
                    dp[i+1] = dp[i-1]
                else:
                    return 0
            else:
                if ((s[i-1] == '1' or s[i-1] == '2') and '1' <= s[i] <= '6') or s[i-1] == '1':
                    dp[i+1] = dp[i] + dp[i-1]
                else:
                    dp[i+1] = dp[i]


        return dp[length]




```