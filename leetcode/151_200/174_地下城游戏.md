# [地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)

## 描述

**困难** 

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 `右 -> 右 -> 下 -> 下`，则骑士的初始健康点数至少为 **7**。

| -2(k) |  -3  |   3   |
| :---: | :--: | :---: |
|  -5   | -10  |   1   |
|  10   |  30  | -5(p) |

**说明:**

- 骑士的健康点数没有上限。
- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

## 解题 

动态规划

从终点倒着推回起点

首先初始化终点的最小血量

- 如果终点的点数是负的，如示例，终点为-5，那么到达终点时，其血量应该为6，减去5后剩下1，骑士还活着，则`dp[-1][-1]=6`

- 如终点为大于0的数，如5，那么到达终点时的最小血量可以为1，则`dp[-1][-1]=1`

然后初始化最后一行和最后一列的最少血量

由于是倒着推的，已知后一个位置的最少血量

- 如果当前位置的点数是负的，相当于后一个位置的最少血量需要加上这个点数的绝对值才是当前位置的最少血量
- 如果当前位置的点数是正的
  - 如果该数大于后一位置的血量，那么该位置的血量可以为1，毕竟1加上该数后已经大于了后一位置的血量
  - 如果该数小于后一位置的血量，那么该位置的血量为后一位置的血量与该数的差值

再正式推理

其他的点都有两条路可以选择，从下往上或者从右往左，选择需要的血量少的后一个位置，然后计算当前的最少血量

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m = len(dungeon)
        n = len(dungeon[0])
        dp = [[0 for i in range(n)] for j in range(m)]
        # 终点
        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])
        # 在最后一行上走
        for i in range(m - 2, -1, -1):
            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1])
		# 在最后一列上走
        for i in range(n - 2, -1, -1):
            dp[m - 1][i] = max(1, dp[m - 1][i + 1] - dungeon[m - 1][i])

        for i in range(m - 2, -1, -1):
            for j in range(n - 2, -1, -1):
                dp[i][j] = max(1, min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i][j])

        return dp[0][0]
```

