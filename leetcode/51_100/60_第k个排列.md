# [第k个排列](https://leetcode-cn.com/problems/permutation-sequence/)

## 描述  
**中等**  

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

    "123"
    "132"
    "213"
    "231"
    "312"
    "321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。

**示例** 

    输入: n = 3, k = 3
    输出: "213"
    
    输入: n = 4, k = 9
    输出: "2314"

## 解题  
按照之前第46题回溯的思路去做  

先回溯生成全排列，在回溯函数中添加判断，已经回溯了k个数据了，返回    

可惜结果是超时的  

按照之前第31题一个个生成下一全排列数字  

结果也是超时的  

啊！！

然后学到了一种很厉害的解法  

对于全排列，n个数有`n!`种排列，而且从1开始排  

如n = 4，k = 15  

- 以1开头的排列：1 +  (2，3，4) 的全排列一共`3! = 6`种  

- 以2开头的排列：2 +  (1，3，4) 的全排列一共`3! = 6`种  

- 以3开头的排列：3 +  (1，2，4) 的全排列一共`3! = 6`种    

- 以4开头的排列：4 +  (1，2，3) 的全排列一共`3! = 6`种  



当为3开头时，6+6+6=18 > k=15  

所以最后答案肯定是3开头，也就是求（1，2，4）全排列的第 15-12 = 3 个    

然后是3开头的排列

- 3 1 + （2，4）的全排列 `2! = 2` 种

- 3 2 + （1，4）的全排列 `2! = 2` 种  

- 3 4 + （1，2）的全排列 `2! = 2` 种

当为32开头时，2+2=4 > 3  

所以开头肯定32，最后也肯定可以找到3214    

全排列的数字nums = [1，2，3，4]  

    第一位数字
    k = 15-1 = 14 从0开始计数
    index = k // (n-1)! = 2，[1,2,3,4]下标为2的数，3
    更新k
    k = k - index*(n-1)! = 2
    
    第二位数字 
    k = 2
    index = k // (n-2)! = 1， [1,2,4]下标为1的数，2
    更新k
    k = k - index*(n-2)! = 0 
    
    第三位数字 
    k = 0
    index = k // (n-3)! = 0，[1,4]下标为0的数，1  
    更新k  
    k = k - index*(n-3)! = 0
    
    第四位数字  
    k = 0  
    index = k // (n-4)! = 0，[4] 下标为0的数，4
    
    结束


```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        # 阶乘
        n_factorial = [1]
        # 用于排列的数字
        nums = []
        # 计算阶乘
        for i in range(1, n+1):
            n_factorial.append(n_factorial[-1]*i)
            nums.append(i)
        
        res = []
        k -= 1
        for i in range(n-1, -1, -1):
            index = k // n_factorial[i] 
            res.append(nums.pop(index))
            k -= index * n_factorial[i]
        
        return ''.join(list(map(lambda x:str(x), res)))
```



​    



